import random

N = 10 
T = 5
p = 0.25 
LAMBDA = 1.5 
max_green_time = 60
max_yellow_time = 10  
max_red_time = 60 
min_signal_time = 10 
traffic_density = [50, 80, 60, 120]  
def fitness_function(signal_times):
    """
    Fitness function to evaluate a set of traffic signal timings.
    We minimize waiting times and congestion for all intersections.
    """
    total_waiting_time = 0
    total_congestion = 0
   
    for i, density in enumerate(traffic_density):
        green_time, yellow_time, red_time = signal_times[i*3:(i+1)*3]
        waiting_time = density * (green_time + yellow_time)
        congestion = density * red_time 

        total_waiting_time += waiting_time
        total_congestion += congestion
    total_cost = total_waiting_time + total_congestion
    return total_cost
def levy_flight():
    """
    Generate a LÃ©vy flight for exploration of the search space.
    """
    u = random.gauss(0, 1)
    v = random.gauss(0, 1)
    flight = u / abs(v)**(1 / 1.5) 
    return flight
def initialize_population():
    """
    Initialize a population of nests (random signal timings for each intersection).
    """
    population = []
    for _ in range(N):
        signal_times = []
        for _ in range(4): 
            green_time = random.randint(min_signal_time, max_green_time)
            yellow_time = random.randint(min_signal_time, max_yellow_time)
            red_time = random.randint(min_signal_time, max_red_time)
            signal_times.extend([green_time, yellow_time, red_time])
        population.append(signal_times)
    return population
def cuckoo_search():
    """
    Cuckoo Search Algorithm for traffic signal optimization.
    """
    population = initialize_population()

    fitness_values = [fitness_function(ind) for ind in population]
   
    best_fitness = min(fitness_values)
    best_solution = population[fitness_values.index(best_fitness)]
    for t in range(T):
        new_population = population[:]
    
        for i in range(N):
            new_solution = population[i][:]  
            for j in range(len(new_solution)):
                new_solution[j] = new_solution[j] + LAMBDA * levy_flight()

                if j % 3 == 0:
                    new_solution[j] = max(min_signal_time, min(new_solution[j], max_green_time))
                elif j % 3 == 1:
                    new_solution[j] = max(min_signal_time, min(new_solution[j], max_yellow_time))
                else:
                    new_solution[j] = max(min_signal_time, min(new_solution[j], max_red_time))
            new_fitness = fitness_function(new_solution)
            if new_fitness < fitness_values[i]:
                population[i] = new_solution
                fitness_values[i] = new_fitness
        for i in range(N):
            if random.random() < p:
                population[i] = initialize_population()[0] 
                fitness_values[i] = fitness_function(population[i])
        current_best_fitness = min(fitness_values)
        if current_best_fitness < best_fitness:
            best_fitness = current_best_fitness
            best_solution = population[fitness_values.index(best_fitness)]
       
        print(f"Generation {t+1}: Best Fitness = {best_fitness}")

    return best_solution, best_fitness
best_signal_timing, best_fitness = cuckoo_search()
print("\nBest Signal Timing Found:")
print(f"Signal Timings (Green, Yellow, Red for each intersection): {best_signal_timing}")
print(f"Best Fitness (Cost): {best_fitness}"